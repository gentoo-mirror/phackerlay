diff --git a/test/CMakeLists.txt b/test/CMakeLists.txt
index 124f0c72fd7..2bf7bf352f4 100644
--- a/test/CMakeLists.txt
+++ b/test/CMakeLists.txt
@@ -143,22 +143,7 @@ endif()
 add_custom_target(llvm-test-depends DEPENDS ${LLVM_TEST_DEPENDS})
 set_target_properties(llvm-test-depends PROPERTIES FOLDER "Tests")

-add_lit_testsuite(check-llvm "Running the LLVM regression tests"
-  ${CMAKE_CURRENT_BINARY_DIR}
-  PARAMS llvm_site_config=${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg
-         llvm_unit_site_config=${CMAKE_CURRENT_BINARY_DIR}/Unit/lit.site.cfg
-  DEPENDS ${LLVM_TEST_DEPENDS}
-  )
-set_target_properties(check-llvm PROPERTIES FOLDER "Tests")
-
-add_lit_testsuites(LLVM ${CMAKE_CURRENT_SOURCE_DIR}
-  PARAMS llvm_site_config=${CMAKE_CURRENT_BINARY_DIR}/lit.site.cfg
-         llvm_unit_site_config=${CMAKE_CURRENT_BINARY_DIR}/Unit/lit.site.cfg
-  DEPENDS ${LLVM_TEST_DEPENDS}
-  )
-
 # Setup a legacy alias for 'check-llvm'. This will likely change to be an
 # alias for 'check-all' at some point in the future.
 add_custom_target(check)
-add_dependencies(check check-llvm)
 set_target_properties(check PROPERTIES FOLDER "Tests")
diff --git a/tools/LLVMBuild.txt b/tools/LLVMBuild.txt
index bcf58842eac..3b032169fae 100644
--- a/tools/LLVMBuild.txt
+++ b/tools/LLVMBuild.txt
@@ -20,7 +20,6 @@ subdirectories =
  bugpoint
  dsymutil
  llc
- lli
  llvm-ar
  llvm-as
  llvm-bcanalyzer
diff --git a/tools/lli/CMakeLists.txt b/tools/lli/CMakeLists.txt
deleted file mode 100644
index f02e19313b7..00000000000
--- a/tools/lli/CMakeLists.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-if ( LLVM_INCLUDE_UTILS )
-  add_subdirectory(ChildTarget)
-endif()
-
-set(LLVM_LINK_COMPONENTS
-  CodeGen
-  Core
-  ExecutionEngine
-  IRReader
-  Interpreter
-  MC
-  MCJIT
-  Object
-  OrcJIT
-  RuntimeDyld
-  SelectionDAG
-  Support
-  Target
-  TransformUtils
-  native
-  )
-
-if( LLVM_USE_OPROFILE )
-  set(LLVM_LINK_COMPONENTS
-    ${LLVM_LINK_COMPONENTS}
-    OProfileJIT
-    )
-endif( LLVM_USE_OPROFILE )
-
-if( LLVM_USE_INTEL_JITEVENTS )
-  set(LLVM_LINK_COMPONENTS
-    ${LLVM_LINK_COMPONENTS}
-    DebugInfoDWARF
-    IntelJITEvents
-    Object
-    )
-endif( LLVM_USE_INTEL_JITEVENTS )
-
-add_llvm_tool(lli
-  lli.cpp
-  OrcLazyJIT.cpp
-
-  DEPENDS
-  intrinsics_gen
-  )
-export_executable_symbols(lli)
diff --git a/tools/lli/ChildTarget/CMakeLists.txt b/tools/lli/ChildTarget/CMakeLists.txt
deleted file mode 100644
index f08ce57c295..00000000000
--- a/tools/lli/ChildTarget/CMakeLists.txt
+++ /dev/null
@@ -1,13 +0,0 @@
-set(LLVM_LINK_COMPONENTS
-  OrcJIT
-  RuntimeDyld
-  Support
-  )
-
-add_llvm_utility(lli-child-target
-  ChildTarget.cpp
-
-  DEPENDS
-  intrinsics_gen
-)
-
diff --git a/tools/lli/ChildTarget/ChildTarget.cpp b/tools/lli/ChildTarget/ChildTarget.cpp
deleted file mode 100644
index 77b1d47a946..00000000000
--- a/tools/lli/ChildTarget/ChildTarget.cpp
+++ /dev/null
@@ -1,67 +0,0 @@
-#include "llvm/ExecutionEngine/Orc/OrcABISupport.h"
-#include "llvm/ExecutionEngine/Orc/OrcRemoteTargetServer.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/DynamicLibrary.h"
-#include "llvm/Support/Process.h"
-#include <sstream>
-
-#include "../RemoteJITUtils.h"
-
-using namespace llvm;
-using namespace llvm::orc;
-using namespace llvm::sys;
-
-#ifdef __x86_64__
-typedef OrcX86_64_SysV HostOrcArch;
-#else
-typedef OrcGenericABI HostOrcArch;
-#endif
-
-ExitOnError ExitOnErr;
-
-int main(int argc, char *argv[]) {
-
-  if (argc != 3) {
-    errs() << "Usage: " << argv[0] << " <input fd> <output fd>\n";
-    return 1;
-  }
-
-  ExitOnErr.setBanner(std::string(argv[0]) + ":");
-
-  int InFD;
-  int OutFD;
-  {
-    std::istringstream InFDStream(argv[1]), OutFDStream(argv[2]);
-    InFDStream >> InFD;
-    OutFDStream >> OutFD;
-  }
-
-  if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr)) {
-    errs() << "Error loading program symbols.\n";
-    return 1;
-  }
-
-  auto SymbolLookup = [](const std::string &Name) {
-    return RTDyldMemoryManager::getSymbolAddressInProcess(Name);
-  };
-
-  auto RegisterEHFrames = [](uint8_t *Addr, uint32_t Size) {
-    RTDyldMemoryManager::registerEHFramesInProcess(Addr, Size);
-  };
-
-  auto DeregisterEHFrames = [](uint8_t *Addr, uint32_t Size) {
-    RTDyldMemoryManager::deregisterEHFramesInProcess(Addr, Size);
-  };
-
-  FDRawChannel Channel(InFD, OutFD);
-  typedef remote::OrcRemoteTargetServer<FDRawChannel, HostOrcArch> JITServer;
-  JITServer Server(Channel, SymbolLookup, RegisterEHFrames, DeregisterEHFrames);
-
-  while (!Server.receivedTerminate())
-    ExitOnErr(Server.handleOne());
-
-  close(InFD);
-  close(OutFD);
-
-  return 0;
-}
diff --git a/tools/lli/ChildTarget/LLVMBuild.txt b/tools/lli/ChildTarget/LLVMBuild.txt
deleted file mode 100644
index daf6df11324..00000000000
--- a/tools/lli/ChildTarget/LLVMBuild.txt
+++ /dev/null
@@ -1,21 +0,0 @@
-;===- ./tools/lli/ChildTarget/LLVMBuild.txt --------------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Tool
-name = lli-child-target
-parent = lli
diff --git a/tools/lli/LLVMBuild.txt b/tools/lli/LLVMBuild.txt
deleted file mode 100644
index 9d889bf4c2e..00000000000
--- a/tools/lli/LLVMBuild.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-;===- ./tools/lli/LLVMBuild.txt --------------------------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[common]
-subdirectories = ChildTarget
-
-[component_0]
-type = Tool
-name = lli
-parent = Tools
-required_libraries =
- AsmParser
- BitReader
- IRReader
- Instrumentation
- Interpreter
- MCJIT
- Native
- NativeCodeGen
- SelectionDAG
- TransformUtils
diff --git a/tools/lli/OrcLazyJIT.cpp b/tools/lli/OrcLazyJIT.cpp
deleted file mode 100644
index f1a752e0790..00000000000
--- a/tools/lli/OrcLazyJIT.cpp
+++ /dev/null
@@ -1,166 +0,0 @@
-//===- OrcLazyJIT.cpp - Basic Orc-based JIT for lazy execution ------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-
-#include "OrcLazyJIT.h"
-#include "llvm/ADT/Triple.h"
-#include "llvm/ExecutionEngine/ExecutionEngine.h"
-#include "llvm/Support/CodeGen.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/DynamicLibrary.h"
-#include "llvm/Support/ErrorHandling.h"
-#include "llvm/Support/FileSystem.h"
-#include <cstdint>
-#include <cstdio>
-#include <cstdlib>
-#include <system_error>
-
-using namespace llvm;
-
-namespace {
-
-enum class DumpKind {
-  NoDump,
-  DumpFuncsToStdOut,
-  DumpModsToStdOut,
-  DumpModsToDisk
-};
-
-} // end anonymous namespace
-
-static cl::opt<DumpKind> OrcDumpKind(
-    "orc-lazy-debug", cl::desc("Debug dumping for the orc-lazy JIT."),
-    cl::init(DumpKind::NoDump),
-    cl::values(clEnumValN(DumpKind::NoDump, "no-dump", "Don't dump anything."),
-               clEnumValN(DumpKind::DumpFuncsToStdOut, "funcs-to-stdout",
-                          "Dump function names to stdout."),
-               clEnumValN(DumpKind::DumpModsToStdOut, "mods-to-stdout",
-                          "Dump modules to stdout."),
-               clEnumValN(DumpKind::DumpModsToDisk, "mods-to-disk",
-                          "Dump modules to the current "
-                          "working directory. (WARNING: "
-                          "will overwrite existing files).")),
-    cl::Hidden);
-
-static cl::opt<bool> OrcInlineStubs("orc-lazy-inline-stubs",
-                                    cl::desc("Try to inline stubs"),
-                                    cl::init(true), cl::Hidden);
-
-OrcLazyJIT::TransformFtor OrcLazyJIT::createDebugDumper() {
-  switch (OrcDumpKind) {
-  case DumpKind::NoDump:
-    return [](std::shared_ptr<Module> M) { return M; };
-
-  case DumpKind::DumpFuncsToStdOut:
-    return [](std::shared_ptr<Module> M) {
-      printf("[ ");
-
-      for (const auto &F : *M) {
-        if (F.isDeclaration())
-          continue;
-
-        if (F.hasName()) {
-          std::string Name(F.getName());
-          printf("%s ", Name.c_str());
-        } else
-          printf("<anon> ");
-      }
-
-      printf("]\n");
-      return M;
-    };
-
-  case DumpKind::DumpModsToStdOut:
-    return [](std::shared_ptr<Module> M) {
-             outs() << "----- Module Start -----\n" << *M
-                    << "----- Module End -----\n";
-
-             return M;
-           };
-
-  case DumpKind::DumpModsToDisk:
-    return [](std::shared_ptr<Module> M) {
-             std::error_code EC;
-             raw_fd_ostream Out(M->getModuleIdentifier() + ".ll", EC,
-                                sys::fs::F_Text);
-             if (EC) {
-               errs() << "Couldn't open " << M->getModuleIdentifier()
-                      << " for dumping.\nError:" << EC.message() << "\n";
-               exit(1);
-             }
-             Out << *M;
-             return M;
-           };
-  }
-  llvm_unreachable("Unknown DumpKind");
-}
-
-// Defined in lli.cpp.
-CodeGenOpt::Level getOptLevel();
-
-template <typename PtrTy>
-static PtrTy fromTargetAddress(JITTargetAddress Addr) {
-  return reinterpret_cast<PtrTy>(static_cast<uintptr_t>(Addr));
-}
-
-int llvm::runOrcLazyJIT(std::vector<std::unique_ptr<Module>> Ms,
-                        const std::vector<std::string> &Args) {
-  // Add the program's symbols into the JIT's search space.
-  if (sys::DynamicLibrary::LoadLibraryPermanently(nullptr)) {
-    errs() << "Error loading program symbols.\n";
-    return 1;
-  }
-
-  // Grab a target machine and try to build a factory function for the
-  // target-specific Orc callback manager.
-  EngineBuilder EB;
-  EB.setOptLevel(getOptLevel());
-  auto TM = std::unique_ptr<TargetMachine>(EB.selectTarget());
-  Triple T(TM->getTargetTriple());
-  auto CompileCallbackMgr = orc::createLocalCompileCallbackManager(T, 0);
-
-  // If we couldn't build the factory function then there must not be a callback
-  // manager for this target. Bail out.
-  if (!CompileCallbackMgr) {
-    errs() << "No callback manager available for target '"
-           << TM->getTargetTriple().str() << "'.\n";
-    return 1;
-  }
-
-  auto IndirectStubsMgrBuilder = orc::createLocalIndirectStubsManagerBuilder(T);
-
-  // If we couldn't build a stubs-manager-builder for this target then bail out.
-  if (!IndirectStubsMgrBuilder) {
-    errs() << "No indirect stubs manager available for target '"
-           << TM->getTargetTriple().str() << "'.\n";
-    return 1;
-  }
-
-  // Everything looks good. Build the JIT.
-  OrcLazyJIT J(std::move(TM), std::move(CompileCallbackMgr),
-               std::move(IndirectStubsMgrBuilder),
-               OrcInlineStubs);
-
-  // Add the module, look up main and run it.
-  for (auto &M : Ms)
-    cantFail(J.addModule(std::shared_ptr<Module>(std::move(M))));
-
-  if (auto MainSym = J.findSymbol("main")) {
-    typedef int (*MainFnPtr)(int, const char*[]);
-    std::vector<const char *> ArgV;
-    for (auto &Arg : Args)
-      ArgV.push_back(Arg.c_str());
-    auto Main = fromTargetAddress<MainFnPtr>(cantFail(MainSym.getAddress()));
-    return Main(ArgV.size(), (const char**)ArgV.data());
-  } else if (auto Err = MainSym.takeError())
-    logAllUnhandledErrors(std::move(Err), llvm::errs(), "");
-  else
-    errs() << "Could not find main function.\n";
-
-  return 1;
-}
diff --git a/tools/lli/OrcLazyJIT.h b/tools/lli/OrcLazyJIT.h
deleted file mode 100644
index 47a2acc4d7e..00000000000
--- a/tools/lli/OrcLazyJIT.h
+++ /dev/null
@@ -1,201 +0,0 @@
-//===- OrcLazyJIT.h - Basic Orc-based JIT for lazy execution ----*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Simple Orc-based JIT. Uses the compile-on-demand layer to break up and
-// lazily compile modules.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_TOOLS_LLI_ORCLAZYJIT_H
-#define LLVM_TOOLS_LLI_ORCLAZYJIT_H
-
-#include "llvm/ADT/STLExtras.h"
-#include "llvm/ADT/Twine.h"
-#include "llvm/ExecutionEngine/JITSymbol.h"
-#include "llvm/ExecutionEngine/Orc/CompileOnDemandLayer.h"
-#include "llvm/ExecutionEngine/Orc/CompileUtils.h"
-#include "llvm/ExecutionEngine/Orc/ExecutionUtils.h"
-#include "llvm/ExecutionEngine/Orc/IndirectionUtils.h"
-#include "llvm/ExecutionEngine/Orc/IRCompileLayer.h"
-#include "llvm/ExecutionEngine/Orc/IRTransformLayer.h"
-#include "llvm/ExecutionEngine/Orc/LambdaResolver.h"
-#include "llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h"
-#include "llvm/ExecutionEngine/RTDyldMemoryManager.h"
-#include "llvm/ExecutionEngine/SectionMemoryManager.h"
-#include "llvm/IR/DataLayout.h"
-#include "llvm/IR/GlobalValue.h"
-#include "llvm/IR/Mangler.h"
-#include "llvm/IR/Module.h"
-#include "llvm/Support/raw_ostream.h"
-#include "llvm/Target/TargetMachine.h"
-#include <algorithm>
-#include <functional>
-#include <memory>
-#include <set>
-#include <string>
-#include <vector>
-
-namespace llvm {
-
-class OrcLazyJIT {
-public:
-
-  using CompileCallbackMgr = orc::JITCompileCallbackManager;
-  using ObjLayerT = orc::RTDyldObjectLinkingLayer;
-  using CompileLayerT = orc::IRCompileLayer<ObjLayerT, orc::SimpleCompiler>;
-  using TransformFtor =
-          std::function<std::shared_ptr<Module>(std::shared_ptr<Module>)>;
-  using IRDumpLayerT = orc::IRTransformLayer<CompileLayerT, TransformFtor>;
-  using CODLayerT = orc::CompileOnDemandLayer<IRDumpLayerT, CompileCallbackMgr>;
-  using IndirectStubsManagerBuilder = CODLayerT::IndirectStubsManagerBuilderT;
-  using ModuleHandleT = CODLayerT::ModuleHandleT;
-
-  OrcLazyJIT(std::unique_ptr<TargetMachine> TM,
-             std::unique_ptr<CompileCallbackMgr> CCMgr,
-             IndirectStubsManagerBuilder IndirectStubsMgrBuilder,
-             bool InlineStubs)
-      : TM(std::move(TM)), DL(this->TM->createDataLayout()),
-       CCMgr(std::move(CCMgr)),
-       ObjectLayer([]() { return std::make_shared<SectionMemoryManager>(); }),
-        CompileLayer(ObjectLayer, orc::SimpleCompiler(*this->TM)),
-        IRDumpLayer(CompileLayer, createDebugDumper()),
-        CODLayer(IRDumpLayer, extractSingleFunction, *this->CCMgr,
-                 std::move(IndirectStubsMgrBuilder), InlineStubs),
-        CXXRuntimeOverrides(
-            [this](const std::string &S) { return mangle(S); }) {}
-
-  ~OrcLazyJIT() {
-    // Run any destructors registered with __cxa_atexit.
-    CXXRuntimeOverrides.runDestructors();
-    // Run any IR destructors.
-    for (auto &DtorRunner : IRStaticDestructorRunners)
-      if (auto Err = DtorRunner.runViaLayer(CODLayer)) {
-        // FIXME: OrcLazyJIT should probably take a "shutdownError" callback to
-        //        report these errors on.
-        report_fatal_error(std::move(Err));
-      }
-  }
-
-  Error addModule(std::shared_ptr<Module> M) {
-    if (M->getDataLayout().isDefault())
-      M->setDataLayout(DL);
-
-    // Rename, bump linkage and record static constructors and destructors.
-    // We have to do this before we hand over ownership of the module to the
-    // JIT.
-    std::vector<std::string> CtorNames, DtorNames;
-    {
-      unsigned CtorId = 0, DtorId = 0;
-      for (auto Ctor : orc::getConstructors(*M)) {
-        std::string NewCtorName = ("$static_ctor." + Twine(CtorId++)).str();
-        Ctor.Func->setName(NewCtorName);
-        Ctor.Func->setLinkage(GlobalValue::ExternalLinkage);
-        Ctor.Func->setVisibility(GlobalValue::HiddenVisibility);
-        CtorNames.push_back(mangle(NewCtorName));
-      }
-      for (auto Dtor : orc::getDestructors(*M)) {
-        std::string NewDtorName = ("$static_dtor." + Twine(DtorId++)).str();
-        Dtor.Func->setLinkage(GlobalValue::ExternalLinkage);
-        Dtor.Func->setVisibility(GlobalValue::HiddenVisibility);
-        DtorNames.push_back(mangle(Dtor.Func->getName()));
-        Dtor.Func->setName(NewDtorName);
-      }
-    }
-
-    // Symbol resolution order:
-    //   1) Search the JIT symbols.
-    //   2) Check for C++ runtime overrides.
-    //   3) Search the host process (LLI)'s symbol table.
-    if (ModulesHandle == CODLayerT::ModuleHandleT()) {
-      auto Resolver =
-        orc::createLambdaResolver(
-          [this](const std::string &Name) -> JITSymbol {
-            if (auto Sym = CODLayer.findSymbol(Name, true))
-              return Sym;
-            return CXXRuntimeOverrides.searchOverrides(Name);
-          },
-          [](const std::string &Name) {
-            if (auto Addr =
-                RTDyldMemoryManager::getSymbolAddressInProcess(Name))
-              return JITSymbol(Addr, JITSymbolFlags::Exported);
-            return JITSymbol(nullptr);
-          }
-        );
-
-      // Add the module to the JIT.
-      if (auto ModulesHandleOrErr =
-          CODLayer.addModule(std::move(M), std::move(Resolver)))
-        ModulesHandle = std::move(*ModulesHandleOrErr);
-      else
-        return ModulesHandleOrErr.takeError();
-
-    } else
-      if (auto Err = CODLayer.addExtraModule(ModulesHandle, std::move(M)))
-        return Err;
-
-    // Run the static constructors, and save the static destructor runner for
-    // execution when the JIT is torn down.
-    orc::CtorDtorRunner<CODLayerT> CtorRunner(std::move(CtorNames),
-                                              ModulesHandle);
-    if (auto Err = CtorRunner.runViaLayer(CODLayer))
-      return Err;
-
-    IRStaticDestructorRunners.emplace_back(std::move(DtorNames),
-                                           ModulesHandle);
-
-    return Error::success();
-  }
-
-  JITSymbol findSymbol(const std::string &Name) {
-    return CODLayer.findSymbol(mangle(Name), true);
-  }
-
-  JITSymbol findSymbolIn(ModuleHandleT H, const std::string &Name) {
-    return CODLayer.findSymbolIn(H, mangle(Name), true);
-  }
-
-private:
-  std::string mangle(const std::string &Name) {
-    std::string MangledName;
-    {
-      raw_string_ostream MangledNameStream(MangledName);
-      Mangler::getNameWithPrefix(MangledNameStream, Name, DL);
-    }
-    return MangledName;
-  }
-
-  static std::set<Function*> extractSingleFunction(Function &F) {
-    std::set<Function*> Partition;
-    Partition.insert(&F);
-    return Partition;
-  }
-
-  static TransformFtor createDebugDumper();
-
-  std::unique_ptr<TargetMachine> TM;
-  DataLayout DL;
-  SectionMemoryManager CCMgrMemMgr;
-
-  std::unique_ptr<CompileCallbackMgr> CCMgr;
-  ObjLayerT ObjectLayer;
-  CompileLayerT CompileLayer;
-  IRDumpLayerT IRDumpLayer;
-  CODLayerT CODLayer;
-
-  orc::LocalCXXRuntimeOverrides CXXRuntimeOverrides;
-  std::vector<orc::CtorDtorRunner<CODLayerT>> IRStaticDestructorRunners;
-  CODLayerT::ModuleHandleT ModulesHandle;
-};
-
-int runOrcLazyJIT(std::vector<std::unique_ptr<Module>> Ms,
-                  const std::vector<std::string> &Args);
-
-} // end namespace llvm
-
-#endif // LLVM_TOOLS_LLI_ORCLAZYJIT_H
diff --git a/tools/lli/RemoteJITUtils.h b/tools/lli/RemoteJITUtils.h
deleted file mode 100644
index 4e948413865..00000000000
--- a/tools/lli/RemoteJITUtils.h
+++ /dev/null
@@ -1,152 +0,0 @@
-//===-- RemoteJITUtils.h - Utilities for remote-JITing with LLI -*- C++ -*-===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// Utilities for remote-JITing with LLI.
-//
-//===----------------------------------------------------------------------===//
-
-#ifndef LLVM_TOOLS_LLI_REMOTEJITUTILS_H
-#define LLVM_TOOLS_LLI_REMOTEJITUTILS_H
-
-#include "llvm/ExecutionEngine/Orc/RawByteChannel.h"
-#include "llvm/ExecutionEngine/RTDyldMemoryManager.h"
-#include <mutex>
-
-#if !defined(_MSC_VER) && !defined(__MINGW32__)
-#include <unistd.h>
-#else
-#include <io.h>
-#endif
-
-/// RPC channel that reads from and writes from file descriptors.
-class FDRawChannel final : public llvm::orc::rpc::RawByteChannel {
-public:
-  FDRawChannel(int InFD, int OutFD) : InFD(InFD), OutFD(OutFD) {}
-
-  llvm::Error readBytes(char *Dst, unsigned Size) override {
-    assert(Dst && "Attempt to read into null.");
-    ssize_t Completed = 0;
-    while (Completed < static_cast<ssize_t>(Size)) {
-      ssize_t Read = ::read(InFD, Dst + Completed, Size - Completed);
-      if (Read <= 0) {
-        auto ErrNo = errno;
-        if (ErrNo == EAGAIN || ErrNo == EINTR)
-          continue;
-        else
-          return llvm::errorCodeToError(
-                   std::error_code(errno, std::generic_category()));
-      }
-      Completed += Read;
-    }
-    return llvm::Error::success();
-  }
-
-  llvm::Error appendBytes(const char *Src, unsigned Size) override {
-    assert(Src && "Attempt to append from null.");
-    ssize_t Completed = 0;
-    while (Completed < static_cast<ssize_t>(Size)) {
-      ssize_t Written = ::write(OutFD, Src + Completed, Size - Completed);
-      if (Written < 0) {
-        auto ErrNo = errno;
-        if (ErrNo == EAGAIN || ErrNo == EINTR)
-          continue;
-        else
-          return llvm::errorCodeToError(
-                   std::error_code(errno, std::generic_category()));
-      }
-      Completed += Written;
-    }
-    return llvm::Error::success();
-  }
-
-  llvm::Error send() override { return llvm::Error::success(); }
-
-private:
-  int InFD, OutFD;
-};
-
-// launch the remote process (see lli.cpp) and return a channel to it.
-std::unique_ptr<FDRawChannel> launchRemote();
-
-namespace llvm {
-
-// ForwardingMM - Adapter to connect MCJIT to Orc's Remote8
-// memory manager.
-class ForwardingMemoryManager : public llvm::RTDyldMemoryManager {
-public:
-  void setMemMgr(std::unique_ptr<RuntimeDyld::MemoryManager> MemMgr) {
-    this->MemMgr = std::move(MemMgr);
-  }
-
-  void setResolver(std::shared_ptr<JITSymbolResolver> Resolver) {
-    this->Resolver = std::move(Resolver);
-  }
-
-  uint8_t *allocateCodeSection(uintptr_t Size, unsigned Alignment,
-                               unsigned SectionID,
-                               StringRef SectionName) override {
-    return MemMgr->allocateCodeSection(Size, Alignment, SectionID, SectionName);
-  }
-
-  uint8_t *allocateDataSection(uintptr_t Size, unsigned Alignment,
-                               unsigned SectionID, StringRef SectionName,
-                               bool IsReadOnly) override {
-    return MemMgr->allocateDataSection(Size, Alignment, SectionID, SectionName,
-                                       IsReadOnly);
-  }
-
-  void reserveAllocationSpace(uintptr_t CodeSize, uint32_t CodeAlign,
-                              uintptr_t RODataSize, uint32_t RODataAlign,
-                              uintptr_t RWDataSize,
-                              uint32_t RWDataAlign) override {
-    MemMgr->reserveAllocationSpace(CodeSize, CodeAlign, RODataSize, RODataAlign,
-                                   RWDataSize, RWDataAlign);
-  }
-
-  bool needsToReserveAllocationSpace() override {
-    return MemMgr->needsToReserveAllocationSpace();
-  }
-
-  void registerEHFrames(uint8_t *Addr, uint64_t LoadAddr,
-                        size_t Size) override {
-    MemMgr->registerEHFrames(Addr, LoadAddr, Size);
-  }
-
-  void deregisterEHFrames() override {
-    MemMgr->deregisterEHFrames();
-  }
-
-  bool finalizeMemory(std::string *ErrMsg = nullptr) override {
-    return MemMgr->finalizeMemory(ErrMsg);
-  }
-
-  void notifyObjectLoaded(RuntimeDyld &RTDyld,
-                          const object::ObjectFile &Obj) override {
-    MemMgr->notifyObjectLoaded(RTDyld, Obj);
-  }
-
-  // Don't hide the sibling notifyObjectLoaded from RTDyldMemoryManager.
-  using RTDyldMemoryManager::notifyObjectLoaded;
-
-  JITSymbol findSymbol(const std::string &Name) override {
-    return Resolver->findSymbol(Name);
-  }
-
-  JITSymbol
-  findSymbolInLogicalDylib(const std::string &Name) override {
-    return Resolver->findSymbolInLogicalDylib(Name);
-  }
-
-private:
-  std::unique_ptr<RuntimeDyld::MemoryManager> MemMgr;
-  std::shared_ptr<JITSymbolResolver> Resolver;
-};
-}
-
-#endif
diff --git a/tools/lli/lli.cpp b/tools/lli/lli.cpp
deleted file mode 100644
index 091ca22b4e8..00000000000
--- a/tools/lli/lli.cpp
+++ /dev/null
@@ -1,759 +0,0 @@
-//===- lli.cpp - LLVM Interpreter / Dynamic compiler ----------------------===//
-//
-//                     The LLVM Compiler Infrastructure
-//
-// This file is distributed under the University of Illinois Open Source
-// License. See LICENSE.TXT for details.
-//
-//===----------------------------------------------------------------------===//
-//
-// This utility provides a simple wrapper around the LLVM Execution Engines,
-// which allow the direct execution of LLVM programs through a Just-In-Time
-// compiler, or through an interpreter if no JIT is available for this platform.
-//
-//===----------------------------------------------------------------------===//
-
-#include "OrcLazyJIT.h"
-#include "RemoteJITUtils.h"
-#include "llvm/IR/LLVMContext.h"
-#include "llvm/ADT/StringExtras.h"
-#include "llvm/ADT/Triple.h"
-#include "llvm/Bitcode/BitcodeReader.h"
-#include "llvm/CodeGen/LinkAllCodegenComponents.h"
-#include "llvm/ExecutionEngine/GenericValue.h"
-#include "llvm/ExecutionEngine/Interpreter.h"
-#include "llvm/ExecutionEngine/JITEventListener.h"
-#include "llvm/ExecutionEngine/MCJIT.h"
-#include "llvm/ExecutionEngine/ObjectCache.h"
-#include "llvm/ExecutionEngine/OrcMCJITReplacement.h"
-#include "llvm/ExecutionEngine/SectionMemoryManager.h"
-#include "llvm/ExecutionEngine/Orc/OrcRemoteTargetClient.h"
-#include "llvm/IR/IRBuilder.h"
-#include "llvm/IR/Module.h"
-#include "llvm/IR/Type.h"
-#include "llvm/IR/TypeBuilder.h"
-#include "llvm/IRReader/IRReader.h"
-#include "llvm/Object/Archive.h"
-#include "llvm/Object/ObjectFile.h"
-#include "llvm/Support/CommandLine.h"
-#include "llvm/Support/Debug.h"
-#include "llvm/Support/DynamicLibrary.h"
-#include "llvm/Support/Format.h"
-#include "llvm/Support/ManagedStatic.h"
-#include "llvm/Support/MathExtras.h"
-#include "llvm/Support/Memory.h"
-#include "llvm/Support/MemoryBuffer.h"
-#include "llvm/Support/Path.h"
-#include "llvm/Support/PluginLoader.h"
-#include "llvm/Support/PrettyStackTrace.h"
-#include "llvm/Support/Process.h"
-#include "llvm/Support/Program.h"
-#include "llvm/Support/Signals.h"
-#include "llvm/Support/SourceMgr.h"
-#include "llvm/Support/TargetSelect.h"
-#include "llvm/Support/raw_ostream.h"
-#include "llvm/Transforms/Instrumentation.h"
-#include <cerrno>
-
-#ifdef __CYGWIN__
-#include <cygwin/version.h>
-#if defined(CYGWIN_VERSION_DLL_MAJOR) && CYGWIN_VERSION_DLL_MAJOR<1007
-#define DO_NOTHING_ATEXIT 1
-#endif
-#endif
-
-using namespace llvm;
-
-#define DEBUG_TYPE "lli"
-
-namespace {
-
-  enum class JITKind { MCJIT, OrcMCJITReplacement, OrcLazy };
-
-  cl::opt<std::string>
-  InputFile(cl::desc("<input bitcode>"), cl::Positional, cl::init("-"));
-
-  cl::list<std::string>
-  InputArgv(cl::ConsumeAfter, cl::desc("<program arguments>..."));
-
-  cl::opt<bool> ForceInterpreter("force-interpreter",
-                                 cl::desc("Force interpretation: disable JIT"),
-                                 cl::init(false));
-
-  cl::opt<JITKind> UseJITKind("jit-kind",
-                              cl::desc("Choose underlying JIT kind."),
-                              cl::init(JITKind::MCJIT),
-                              cl::values(
-                                clEnumValN(JITKind::MCJIT, "mcjit",
-                                           "MCJIT"),
-                                clEnumValN(JITKind::OrcMCJITReplacement,
-                                           "orc-mcjit",
-                                           "Orc-based MCJIT replacement"),
-                                clEnumValN(JITKind::OrcLazy,
-                                           "orc-lazy",
-                                           "Orc-based lazy JIT.")));
-
-  // The MCJIT supports building for a target address space separate from
-  // the JIT compilation process. Use a forked process and a copying
-  // memory manager with IPC to execute using this functionality.
-  cl::opt<bool> RemoteMCJIT("remote-mcjit",
-    cl::desc("Execute MCJIT'ed code in a separate process."),
-    cl::init(false));
-
-  // Manually specify the child process for remote execution. This overrides
-  // the simulated remote execution that allocates address space for child
-  // execution. The child process will be executed and will communicate with
-  // lli via stdin/stdout pipes.
-  cl::opt<std::string>
-  ChildExecPath("mcjit-remote-process",
-                cl::desc("Specify the filename of the process to launch "
-                         "for remote MCJIT execution.  If none is specified,"
-                         "\n\tremote execution will be simulated in-process."),
-                cl::value_desc("filename"), cl::init(""));
-
-  // Determine optimization level.
-  cl::opt<char>
-  OptLevel("O",
-           cl::desc("Optimization level. [-O0, -O1, -O2, or -O3] "
-                    "(default = '-O2')"),
-           cl::Prefix,
-           cl::ZeroOrMore,
-           cl::init(' '));
-
-  cl::opt<std::string>
-  TargetTriple("mtriple", cl::desc("Override target triple for module"));
-
-  cl::opt<std::string>
-  MArch("march",
-        cl::desc("Architecture to generate assembly for (see --version)"));
-
-  cl::opt<std::string>
-  MCPU("mcpu",
-       cl::desc("Target a specific cpu type (-mcpu=help for details)"),
-       cl::value_desc("cpu-name"),
-       cl::init(""));
-
-  cl::list<std::string>
-  MAttrs("mattr",
-         cl::CommaSeparated,
-         cl::desc("Target specific attributes (-mattr=help for details)"),
-         cl::value_desc("a1,+a2,-a3,..."));
-
-  cl::opt<std::string>
-  EntryFunc("entry-function",
-            cl::desc("Specify the entry function (default = 'main') "
-                     "of the executable"),
-            cl::value_desc("function"),
-            cl::init("main"));
-
-  cl::list<std::string>
-  ExtraModules("extra-module",
-         cl::desc("Extra modules to be loaded"),
-         cl::value_desc("input bitcode"));
-
-  cl::list<std::string>
-  ExtraObjects("extra-object",
-         cl::desc("Extra object files to be loaded"),
-         cl::value_desc("input object"));
-
-  cl::list<std::string>
-  ExtraArchives("extra-archive",
-         cl::desc("Extra archive files to be loaded"),
-         cl::value_desc("input archive"));
-
-  cl::opt<bool>
-  EnableCacheManager("enable-cache-manager",
-        cl::desc("Use cache manager to save/load mdoules"),
-        cl::init(false));
-
-  cl::opt<std::string>
-  ObjectCacheDir("object-cache-dir",
-                  cl::desc("Directory to store cached object files "
-                           "(must be user writable)"),
-                  cl::init(""));
-
-  cl::opt<std::string>
-  FakeArgv0("fake-argv0",
-            cl::desc("Override the 'argv[0]' value passed into the executing"
-                     " program"), cl::value_desc("executable"));
-
-  cl::opt<bool>
-  DisableCoreFiles("disable-core-files", cl::Hidden,
-                   cl::desc("Disable emission of core files if possible"));
-
-  cl::opt<bool>
-  NoLazyCompilation("disable-lazy-compilation",
-                  cl::desc("Disable JIT lazy compilation"),
-                  cl::init(false));
-
-  cl::opt<Reloc::Model> RelocModel(
-      "relocation-model", cl::desc("Choose relocation model"),
-      cl::values(
-          clEnumValN(Reloc::Static, "static", "Non-relocatable code"),
-          clEnumValN(Reloc::PIC_, "pic",
-                     "Fully relocatable, position independent code"),
-          clEnumValN(Reloc::DynamicNoPIC, "dynamic-no-pic",
-                     "Relocatable external references, non-relocatable code")));
-
-  cl::opt<llvm::CodeModel::Model>
-  CMModel("code-model",
-          cl::desc("Choose code model"),
-          cl::init(CodeModel::JITDefault),
-          cl::values(clEnumValN(CodeModel::JITDefault, "default",
-                                "Target default JIT code model"),
-                     clEnumValN(CodeModel::Small, "small",
-                                "Small code model"),
-                     clEnumValN(CodeModel::Kernel, "kernel",
-                                "Kernel code model"),
-                     clEnumValN(CodeModel::Medium, "medium",
-                                "Medium code model"),
-                     clEnumValN(CodeModel::Large, "large",
-                                "Large code model")));
-
-  cl::opt<bool>
-  GenerateSoftFloatCalls("soft-float",
-    cl::desc("Generate software floating point library calls"),
-    cl::init(false));
-
-  cl::opt<llvm::FloatABI::ABIType>
-  FloatABIForCalls("float-abi",
-                   cl::desc("Choose float ABI type"),
-                   cl::init(FloatABI::Default),
-                   cl::values(
-                     clEnumValN(FloatABI::Default, "default",
-                                "Target default float ABI type"),
-                     clEnumValN(FloatABI::Soft, "soft",
-                                "Soft float ABI (implied by -soft-float)"),
-                     clEnumValN(FloatABI::Hard, "hard",
-                                "Hard float ABI (uses FP registers)")));
-
-  ExitOnError ExitOnErr;
-}
-
-//===----------------------------------------------------------------------===//
-// Object cache
-//
-// This object cache implementation writes cached objects to disk to the
-// directory specified by CacheDir, using a filename provided in the module
-// descriptor. The cache tries to load a saved object using that path if the
-// file exists. CacheDir defaults to "", in which case objects are cached
-// alongside their originating bitcodes.
-//
-class LLIObjectCache : public ObjectCache {
-public:
-  LLIObjectCache(const std::string& CacheDir) : CacheDir(CacheDir) {
-    // Add trailing '/' to cache dir if necessary.
-    if (!this->CacheDir.empty() &&
-        this->CacheDir[this->CacheDir.size() - 1] != '/')
-      this->CacheDir += '/';
-  }
-  ~LLIObjectCache() override {}
-
-  void notifyObjectCompiled(const Module *M, MemoryBufferRef Obj) override {
-    const std::string &ModuleID = M->getModuleIdentifier();
-    std::string CacheName;
-    if (!getCacheFilename(ModuleID, CacheName))
-      return;
-    if (!CacheDir.empty()) { // Create user-defined cache dir.
-      SmallString<128> dir(sys::path::parent_path(CacheName));
-      sys::fs::create_directories(Twine(dir));
-    }
-    std::error_code EC;
-    raw_fd_ostream outfile(CacheName, EC, sys::fs::F_None);
-    outfile.write(Obj.getBufferStart(), Obj.getBufferSize());
-    outfile.close();
-  }
-
-  std::unique_ptr<MemoryBuffer> getObject(const Module* M) override {
-    const std::string &ModuleID = M->getModuleIdentifier();
-    std::string CacheName;
-    if (!getCacheFilename(ModuleID, CacheName))
-      return nullptr;
-    // Load the object from the cache filename
-    ErrorOr<std::unique_ptr<MemoryBuffer>> IRObjectBuffer =
-        MemoryBuffer::getFile(CacheName, -1, false);
-    // If the file isn't there, that's OK.
-    if (!IRObjectBuffer)
-      return nullptr;
-    // MCJIT will want to write into this buffer, and we don't want that
-    // because the file has probably just been mmapped.  Instead we make
-    // a copy.  The filed-based buffer will be released when it goes
-    // out of scope.
-    return MemoryBuffer::getMemBufferCopy(IRObjectBuffer.get()->getBuffer());
-  }
-
-private:
-  std::string CacheDir;
-
-  bool getCacheFilename(const std::string &ModID, std::string &CacheName) {
-    std::string Prefix("file:");
-    size_t PrefixLength = Prefix.length();
-    if (ModID.substr(0, PrefixLength) != Prefix)
-      return false;
-        std::string CacheSubdir = ModID.substr(PrefixLength);
-#if defined(_WIN32)
-        // Transform "X:\foo" => "/X\foo" for convenience.
-        if (isalpha(CacheSubdir[0]) && CacheSubdir[1] == ':') {
-          CacheSubdir[1] = CacheSubdir[0];
-          CacheSubdir[0] = '/';
-        }
-#endif
-    CacheName = CacheDir + CacheSubdir;
-    size_t pos = CacheName.rfind('.');
-    CacheName.replace(pos, CacheName.length() - pos, ".o");
-    return true;
-  }
-};
-
-// On Mingw and Cygwin, an external symbol named '__main' is called from the
-// generated 'main' function to allow static initialization.  To avoid linking
-// problems with remote targets (because lli's remote target support does not
-// currently handle external linking) we add a secondary module which defines
-// an empty '__main' function.
-static void addCygMingExtraModule(ExecutionEngine &EE, LLVMContext &Context,
-                                  StringRef TargetTripleStr) {
-  IRBuilder<> Builder(Context);
-  Triple TargetTriple(TargetTripleStr);
-
-  // Create a new module.
-  std::unique_ptr<Module> M = make_unique<Module>("CygMingHelper", Context);
-  M->setTargetTriple(TargetTripleStr);
-
-  // Create an empty function named "__main".
-  Function *Result;
-  if (TargetTriple.isArch64Bit()) {
-    Result = Function::Create(
-      TypeBuilder<int64_t(void), false>::get(Context),
-      GlobalValue::ExternalLinkage, "__main", M.get());
-  } else {
-    Result = Function::Create(
-      TypeBuilder<int32_t(void), false>::get(Context),
-      GlobalValue::ExternalLinkage, "__main", M.get());
-  }
-  BasicBlock *BB = BasicBlock::Create(Context, "__main", Result);
-  Builder.SetInsertPoint(BB);
-  Value *ReturnVal;
-  if (TargetTriple.isArch64Bit())
-    ReturnVal = ConstantInt::get(Context, APInt(64, 0));
-  else
-    ReturnVal = ConstantInt::get(Context, APInt(32, 0));
-  Builder.CreateRet(ReturnVal);
-
-  // Add this new module to the ExecutionEngine.
-  EE.addModule(std::move(M));
-}
-
-CodeGenOpt::Level getOptLevel() {
-  switch (OptLevel) {
-  default:
-    errs() << "lli: Invalid optimization level.\n";
-    exit(1);
-  case '0': return CodeGenOpt::None;
-  case '1': return CodeGenOpt::Less;
-  case ' ':
-  case '2': return CodeGenOpt::Default;
-  case '3': return CodeGenOpt::Aggressive;
-  }
-  llvm_unreachable("Unrecognized opt level.");
-}
-
-LLVM_ATTRIBUTE_NORETURN
-static void reportError(SMDiagnostic Err, const char *ProgName) {
-  Err.print(ProgName, errs());
-  exit(1);
-}
-
-//===----------------------------------------------------------------------===//
-// main Driver function
-//
-int main(int argc, char **argv, char * const *envp) {
-  sys::PrintStackTraceOnErrorSignal(argv[0]);
-  PrettyStackTraceProgram X(argc, argv);
-
-  atexit(llvm_shutdown); // Call llvm_shutdown() on exit.
-
-  if (argc > 1)
-    ExitOnErr.setBanner(std::string(argv[0]) + ": ");
-
-  // If we have a native target, initialize it to ensure it is linked in and
-  // usable by the JIT.
-  InitializeNativeTarget();
-  InitializeNativeTargetAsmPrinter();
-  InitializeNativeTargetAsmParser();
-
-  cl::ParseCommandLineOptions(argc, argv,
-                              "llvm interpreter & dynamic compiler\n");
-
-  // If the user doesn't want core files, disable them.
-  if (DisableCoreFiles)
-    sys::Process::PreventCoreFiles();
-
-  LLVMContext Context;
-
-  // Load the bitcode...
-  SMDiagnostic Err;
-  std::unique_ptr<Module> Owner = parseIRFile(InputFile, Err, Context);
-  Module *Mod = Owner.get();
-  if (!Mod)
-    reportError(Err, argv[0]);
-
-  if (UseJITKind == JITKind::OrcLazy) {
-    std::vector<std::unique_ptr<Module>> Ms;
-    Ms.push_back(std::move(Owner));
-    for (auto &ExtraMod : ExtraModules) {
-      Ms.push_back(parseIRFile(ExtraMod, Err, Context));
-      if (!Ms.back())
-        reportError(Err, argv[0]);
-    }
-    std::vector<std::string> Args;
-    Args.push_back(InputFile);
-    for (auto &Arg : InputArgv)
-      Args.push_back(Arg);
-    return runOrcLazyJIT(std::move(Ms), Args);
-  }
-
-  if (EnableCacheManager) {
-    std::string CacheName("file:");
-    CacheName.append(InputFile);
-    Mod->setModuleIdentifier(CacheName);
-  }
-
-  // If not jitting lazily, load the whole bitcode file eagerly too.
-  if (NoLazyCompilation) {
-    // Use *argv instead of argv[0] to work around a wrong GCC warning.
-    ExitOnError ExitOnErr(std::string(*argv) +
-                          ": bitcode didn't read correctly: ");
-    ExitOnErr(Mod->materializeAll());
-  }
-
-  std::string ErrorMsg;
-  EngineBuilder builder(std::move(Owner));
-  builder.setMArch(MArch);
-  builder.setMCPU(MCPU);
-  builder.setMAttrs(MAttrs);
-  if (RelocModel.getNumOccurrences())
-    builder.setRelocationModel(RelocModel);
-  builder.setCodeModel(CMModel);
-  builder.setErrorStr(&ErrorMsg);
-  builder.setEngineKind(ForceInterpreter
-                        ? EngineKind::Interpreter
-                        : EngineKind::JIT);
-  builder.setUseOrcMCJITReplacement(UseJITKind == JITKind::OrcMCJITReplacement);
-
-  // If we are supposed to override the target triple, do so now.
-  if (!TargetTriple.empty())
-    Mod->setTargetTriple(Triple::normalize(TargetTriple));
-
-  // Enable MCJIT if desired.
-  RTDyldMemoryManager *RTDyldMM = nullptr;
-  if (!ForceInterpreter) {
-    if (RemoteMCJIT)
-      RTDyldMM = new ForwardingMemoryManager();
-    else
-      RTDyldMM = new SectionMemoryManager();
-
-    // Deliberately construct a temp std::unique_ptr to pass in. Do not null out
-    // RTDyldMM: We still use it below, even though we don't own it.
-    builder.setMCJITMemoryManager(
-      std::unique_ptr<RTDyldMemoryManager>(RTDyldMM));
-  } else if (RemoteMCJIT) {
-    errs() << "error: Remote process execution does not work with the "
-              "interpreter.\n";
-    exit(1);
-  }
-
-  builder.setOptLevel(getOptLevel());
-
-  TargetOptions Options;
-  if (FloatABIForCalls != FloatABI::Default)
-    Options.FloatABIType = FloatABIForCalls;
-
-  builder.setTargetOptions(Options);
-
-  std::unique_ptr<ExecutionEngine> EE(builder.create());
-  if (!EE) {
-    if (!ErrorMsg.empty())
-      errs() << argv[0] << ": error creating EE: " << ErrorMsg << "\n";
-    else
-      errs() << argv[0] << ": unknown error creating EE!\n";
-    exit(1);
-  }
-
-  std::unique_ptr<LLIObjectCache> CacheManager;
-  if (EnableCacheManager) {
-    CacheManager.reset(new LLIObjectCache(ObjectCacheDir));
-    EE->setObjectCache(CacheManager.get());
-  }
-
-  // Load any additional modules specified on the command line.
-  for (unsigned i = 0, e = ExtraModules.size(); i != e; ++i) {
-    std::unique_ptr<Module> XMod = parseIRFile(ExtraModules[i], Err, Context);
-    if (!XMod)
-      reportError(Err, argv[0]);
-    if (EnableCacheManager) {
-      std::string CacheName("file:");
-      CacheName.append(ExtraModules[i]);
-      XMod->setModuleIdentifier(CacheName);
-    }
-    EE->addModule(std::move(XMod));
-  }
-
-  for (unsigned i = 0, e = ExtraObjects.size(); i != e; ++i) {
-    Expected<object::OwningBinary<object::ObjectFile>> Obj =
-        object::ObjectFile::createObjectFile(ExtraObjects[i]);
-    if (!Obj) {
-      // TODO: Actually report errors helpfully.
-      consumeError(Obj.takeError());
-      reportError(Err, argv[0]);
-    }
-    object::OwningBinary<object::ObjectFile> &O = Obj.get();
-    EE->addObjectFile(std::move(O));
-  }
-
-  for (unsigned i = 0, e = ExtraArchives.size(); i != e; ++i) {
-    ErrorOr<std::unique_ptr<MemoryBuffer>> ArBufOrErr =
-        MemoryBuffer::getFileOrSTDIN(ExtraArchives[i]);
-    if (!ArBufOrErr)
-      reportError(Err, argv[0]);
-    std::unique_ptr<MemoryBuffer> &ArBuf = ArBufOrErr.get();
-
-    Expected<std::unique_ptr<object::Archive>> ArOrErr =
-        object::Archive::create(ArBuf->getMemBufferRef());
-    if (!ArOrErr) {
-      std::string Buf;
-      raw_string_ostream OS(Buf);
-      logAllUnhandledErrors(ArOrErr.takeError(), OS, "");
-      OS.flush();
-      errs() << Buf;
-      exit(1);
-    }
-    std::unique_ptr<object::Archive> &Ar = ArOrErr.get();
-
-    object::OwningBinary<object::Archive> OB(std::move(Ar), std::move(ArBuf));
-
-    EE->addArchive(std::move(OB));
-  }
-
-  // If the target is Cygwin/MingW and we are generating remote code, we
-  // need an extra module to help out with linking.
-  if (RemoteMCJIT && Triple(Mod->getTargetTriple()).isOSCygMing()) {
-    addCygMingExtraModule(*EE, Context, Mod->getTargetTriple());
-  }
-
-  // The following functions have no effect if their respective profiling
-  // support wasn't enabled in the build configuration.
-  EE->RegisterJITEventListener(
-                JITEventListener::createOProfileJITEventListener());
-  EE->RegisterJITEventListener(
-                JITEventListener::createIntelJITEventListener());
-
-  if (!NoLazyCompilation && RemoteMCJIT) {
-    errs() << "warning: remote mcjit does not support lazy compilation\n";
-    NoLazyCompilation = true;
-  }
-  EE->DisableLazyCompilation(NoLazyCompilation);
-
-  // If the user specifically requested an argv[0] to pass into the program,
-  // do it now.
-  if (!FakeArgv0.empty()) {
-    InputFile = static_cast<std::string>(FakeArgv0);
-  } else {
-    // Otherwise, if there is a .bc suffix on the executable strip it off, it
-    // might confuse the program.
-    if (StringRef(InputFile).endswith(".bc"))
-      InputFile.erase(InputFile.length() - 3);
-  }
-
-  // Add the module's name to the start of the vector of arguments to main().
-  InputArgv.insert(InputArgv.begin(), InputFile);
-
-  // Call the main function from M as if its signature were:
-  //   int main (int argc, char **argv, const char **envp)
-  // using the contents of Args to determine argc & argv, and the contents of
-  // EnvVars to determine envp.
-  //
-  Function *EntryFn = Mod->getFunction(EntryFunc);
-  if (!EntryFn) {
-    errs() << '\'' << EntryFunc << "\' function not found in module.\n";
-    return -1;
-  }
-
-  // Reset errno to zero on entry to main.
-  errno = 0;
-
-  int Result = -1;
-
-  // Sanity check use of remote-jit: LLI currently only supports use of the
-  // remote JIT on Unix platforms.
-  if (RemoteMCJIT) {
-#ifndef LLVM_ON_UNIX
-    errs() << "Warning: host does not support external remote targets.\n"
-           << "  Defaulting to local execution\n";
-    return -1;
-#else
-    if (ChildExecPath.empty()) {
-      errs() << "-remote-mcjit requires -mcjit-remote-process.\n";
-      exit(1);
-    } else if (!sys::fs::can_execute(ChildExecPath)) {
-      errs() << "Unable to find usable child executable: '" << ChildExecPath
-             << "'\n";
-      return -1;
-    }
-#endif
-  }
-
-  if (!RemoteMCJIT) {
-    // If the program doesn't explicitly call exit, we will need the Exit
-    // function later on to make an explicit call, so get the function now.
-    Constant *Exit = Mod->getOrInsertFunction("exit", Type::getVoidTy(Context),
-                                                      Type::getInt32Ty(Context));
-
-    // Run static constructors.
-    if (!ForceInterpreter) {
-      // Give MCJIT a chance to apply relocations and set page permissions.
-      EE->finalizeObject();
-    }
-    EE->runStaticConstructorsDestructors(false);
-
-    // Trigger compilation separately so code regions that need to be
-    // invalidated will be known.
-    (void)EE->getPointerToFunction(EntryFn);
-    // Clear instruction cache before code will be executed.
-    if (RTDyldMM)
-      static_cast<SectionMemoryManager*>(RTDyldMM)->invalidateInstructionCache();
-
-    // Run main.
-    Result = EE->runFunctionAsMain(EntryFn, InputArgv, envp);
-
-    // Run static destructors.
-    EE->runStaticConstructorsDestructors(true);
-
-    // If the program didn't call exit explicitly, we should call it now.
-    // This ensures that any atexit handlers get called correctly.
-    if (Function *ExitF = dyn_cast<Function>(Exit)) {
-      std::vector<GenericValue> Args;
-      GenericValue ResultGV;
-      ResultGV.IntVal = APInt(32, Result);
-      Args.push_back(ResultGV);
-      EE->runFunction(ExitF, Args);
-      errs() << "ERROR: exit(" << Result << ") returned!\n";
-      abort();
-    } else {
-      errs() << "ERROR: exit defined with wrong prototype!\n";
-      abort();
-    }
-  } else {
-    // else == "if (RemoteMCJIT)"
-
-    // Remote target MCJIT doesn't (yet) support static constructors. No reason
-    // it couldn't. This is a limitation of the LLI implementation, not the
-    // MCJIT itself. FIXME.
-
-    // Lanch the remote process and get a channel to it.
-    std::unique_ptr<FDRawChannel> C = launchRemote();
-    if (!C) {
-      errs() << "Failed to launch remote JIT.\n";
-      exit(1);
-    }
-
-    // Create a remote target client running over the channel.
-    typedef orc::remote::OrcRemoteTargetClient<orc::rpc::RawByteChannel>
-      MyRemote;
-    auto R = ExitOnErr(MyRemote::Create(*C));
-
-    // Create a remote memory manager.
-    std::unique_ptr<MyRemote::RCMemoryManager> RemoteMM;
-    ExitOnErr(R->createRemoteMemoryManager(RemoteMM));
-
-    // Forward MCJIT's memory manager calls to the remote memory manager.
-    static_cast<ForwardingMemoryManager*>(RTDyldMM)->setMemMgr(
-      std::move(RemoteMM));
-
-    // Forward MCJIT's symbol resolution calls to the remote.
-    static_cast<ForwardingMemoryManager*>(RTDyldMM)->setResolver(
-      orc::createLambdaResolver(
-        [](const std::string &Name) { return nullptr; },
-        [&](const std::string &Name) {
-          if (auto Addr = ExitOnErr(R->getSymbolAddress(Name)))
-           return JITSymbol(Addr, JITSymbolFlags::Exported);
-          return JITSymbol(nullptr);
-        }
-      ));
-
-    // Grab the target address of the JIT'd main function on the remote and call
-    // it.
-    // FIXME: argv and envp handling.
-    JITTargetAddress Entry = EE->getFunctionAddress(EntryFn->getName().str());
-    EE->finalizeObject();
-    DEBUG(dbgs() << "Executing '" << EntryFn->getName() << "' at 0x"
-                 << format("%llx", Entry) << "\n");
-    Result = ExitOnErr(R->callIntVoid(Entry));
-
-    // Like static constructors, the remote target MCJIT support doesn't handle
-    // this yet. It could. FIXME.
-
-    // Delete the EE - we need to tear it down *before* we terminate the session
-    // with the remote, otherwise it'll crash when it tries to release resources
-    // on a remote that has already been disconnected.
-    EE.reset();
-
-    // Signal the remote target that we're done JITing.
-    ExitOnErr(R->terminateSession());
-  }
-
-  return Result;
-}
-
-std::unique_ptr<FDRawChannel> launchRemote() {
-#ifndef LLVM_ON_UNIX
-  llvm_unreachable("launchRemote not supported on non-Unix platforms");
-#else
-  int PipeFD[2][2];
-  pid_t ChildPID;
-
-  // Create two pipes.
-  if (pipe(PipeFD[0]) != 0 || pipe(PipeFD[1]) != 0)
-    perror("Error creating pipe: ");
-
-  ChildPID = fork();
-
-  if (ChildPID == 0) {
-    // In the child...
-
-    // Close the parent ends of the pipes
-    close(PipeFD[0][1]);
-    close(PipeFD[1][0]);
-
-
-    // Execute the child process.
-    std::unique_ptr<char[]> ChildPath, ChildIn, ChildOut;
-    {
-      ChildPath.reset(new char[ChildExecPath.size() + 1]);
-      std::copy(ChildExecPath.begin(), ChildExecPath.end(), &ChildPath[0]);
-      ChildPath[ChildExecPath.size()] = '\0';
-      std::string ChildInStr = utostr(PipeFD[0][0]);
-      ChildIn.reset(new char[ChildInStr.size() + 1]);
-      std::copy(ChildInStr.begin(), ChildInStr.end(), &ChildIn[0]);
-      ChildIn[ChildInStr.size()] = '\0';
-      std::string ChildOutStr = utostr(PipeFD[1][1]);
-      ChildOut.reset(new char[ChildOutStr.size() + 1]);
-      std::copy(ChildOutStr.begin(), ChildOutStr.end(), &ChildOut[0]);
-      ChildOut[ChildOutStr.size()] = '\0';
-    }
-
-    char * const args[] = { &ChildPath[0], &ChildIn[0], &ChildOut[0], nullptr };
-    int rc = execv(ChildExecPath.c_str(), args);
-    if (rc != 0)
-      perror("Error executing child process: ");
-    llvm_unreachable("Error executing child process");
-  }
-  // else we're the parent...
-
-  // Close the child ends of the pipes
-  close(PipeFD[0][0]);
-  close(PipeFD[1][1]);
-
-  // Return an RPC channel connected to our end of the pipes.
-  return llvm::make_unique<FDRawChannel>(PipeFD[1][0], PipeFD[0][1]);
-#endif
-}
